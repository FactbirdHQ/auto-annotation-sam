from typing import Optional, Union, List, Dict
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt


def show_masks_sam(
    image: np.ndarray,
    masks: Union[np.ndarray, List[Dict]],
    scores: Optional[np.ndarray] = None,
    alpha: Optional[float] = 0.5,
    display_image: Optional[bool] = True,  # Changed default to True
    only_best: Optional[bool] = True,
    autogenerated_mask: Optional[bool] = False,
) -> Image.Image:
    """
    Display segmentation masks on an image.
    
    Parameters:
        image (np.ndarray): Input image as a numpy array.
        masks (np.ndarray or List[Dict]): Either a numpy array of masks or a list of dictionaries
                                         with "segmentation" and "area" keys.
        scores (np.ndarray, optional): Confidence scores for masks.
        alpha (float, optional): Transparency of masks. Default is 0.5.
        display_image (bool, optional): Whether to display masks on the input image. Default is False.
        only_best (bool, optional): Whether to only display the mask with highest score. Default is True.
        autogenerated_mask (bool, optional): Whether masks are in autogenerated format. Default is False.
        
    Returns:
        PIL.Image.Image: Image with overlaid masks
    """
    # Handle sorting by scores if provided
    if scores is not None and not autogenerated_mask:
        # Sort masks by their scores
        sorted_ind = np.argsort(scores)[::-1]
        masks = masks[sorted_ind]

    # Get dimensions from the input
    if display_image:
        # Use the input image dimensions
        if image.ndim == 3:  # Color image
            h, w = image.shape[:2]
        else:  # Grayscale image
            h, w = image.shape
    elif autogenerated_mask:
        # For autogenerated masks, get dimensions from the first mask
        if isinstance(masks, list) and masks and 'segmentation' in masks[0]:
            h, w = masks[0]['segmentation'].shape
        else:
            raise ValueError("Autogenerated masks should be a list of dictionaries with 'segmentation' key")
    else:
        # For regular masks, get dimensions from the mask array
        if masks.ndim == 3:  # Multiple masks
            h, w = masks.shape[1:]
        else:  # Single mask
            h, w = masks.shape

    # Prepare the output image
    if display_image:
        # Convert input image to PIL and ensure RGBA mode
        if image.dtype == np.uint8:
            output_image = Image.fromarray(image)
        else:
            output_image = Image.fromarray((image * 255).astype(np.uint8))
            
        if output_image.mode != 'RGBA':
            output_image = output_image.convert('RGBA')
    else:
        # Create a new blank image
        output_image = Image.new(mode="RGBA", size=(w, h), color=(0, 0, 0, 0))  # Fully transparent
        
        # If we have the original image, blend it in even when display_image is False
        # This ensures masks are displayed on top of the original image
        if image is not None:
            img_pil = Image.fromarray(image if image.dtype == np.uint8 else (image * 255).astype(np.uint8))
            if img_pil.mode != 'RGBA':
                img_pil = img_pil.convert('RGBA')
            # Resize if needed
            if img_pil.size != output_image.size:
                img_pil = img_pil.resize((w, h))
            output_image = img_pil.copy()

    # Process each mask
    if autogenerated_mask:
        # Sort by area if autogenerated
        if isinstance(masks, list) and masks and 'area' in masks[0]:
            masks = sorted(masks, key=(lambda x: x["area"]), reverse=True)
    
    # Iterate through masks
    mask_count = len(masks) if isinstance(masks, list) else masks.shape[0]
    for i in range(mask_count):
        if autogenerated_mask:
            if isinstance(masks, list) and 'segmentation' in masks[i]:
                mask = masks[i]["segmentation"]
            else:
                raise ValueError("Expected masks to be a list of dicts with 'segmentation' key when autogenerated_mask=True")
        else:
            if masks.ndim > 2:
                mask = masks[i]
                if mask.ndim > 2:  # Handle extra dimensions
                    mask = mask.squeeze()
            else:
                mask = masks  # Single mask case

        # Generate a random color with specified alpha value
        color = np.concatenate(
            (np.random.randint(0, 256, size=3), [int(alpha * 255)]), axis=0
        )

        # Create an RGBA image for the mask
        # Ensure mask has values 0-1 for binary mask
        if mask.dtype != np.bool_:
            if np.max(mask) > 1.0:
                mask = (mask > 0).astype(np.uint8)
            else:
                mask = (mask > 0.5).astype(np.uint8)
        
        # Print debug info (uncomment if needed)
        # print(f"Mask shape: {mask.shape}, Output image size: {output_image.size}")
        
        # Ensure mask dimensions match output_image dimensions (widthÃ—height in PIL)
        expected_h, expected_w = output_image.size[1], output_image.size[0]
        if mask.shape[0] != expected_h or mask.shape[1] != expected_w:
            # Resize mask to match output_image dimensions
            # Note: NumPy and PIL have different dimension ordering
            mask_resized = np.zeros((expected_h, expected_w), dtype=mask.dtype)
            # Copy values where possible
            min_h = min(mask.shape[0], expected_h)
            min_w = min(mask.shape[1], expected_w)
            mask_resized[:min_h, :min_w] = mask[:min_h, :min_w]
            mask = mask_resized
                
        mask_image = Image.fromarray((mask * 255).astype(np.uint8)).convert("L")
        mask_colored = Image.new("RGBA", mask_image.size, tuple(color))
        mask_overlay = Image.new("RGBA", mask_image.size, (0, 0, 0, 0))
        mask_image = Image.composite(mask_colored, mask_overlay, mask_image)

        # Overlay mask on the output image
        output_image = Image.alpha_composite(output_image, mask_image)

        # Exit if specified to only display the best mask
        if only_best:
            break

    return output_image

def create_transparent_mask_overlay(image, masks, alpha=0.4, color=[255, 0, 0]):
    """
    Creates a semi-transparent overlay of masks on an image.
    
    Args:
        image: PIL Image or numpy array of the original image
        masks: List of binary masks (numpy arrays or PIL Images)
        alpha: Transparency level of the overlay (0.0 to 1.0)
        color: RGB color list for the mask overlay [R, G, B]
        
    Returns:
        PIL Image with transparent mask overlay
    """
    # Convert image to numpy array if it's a PIL Image
    if isinstance(image, Image.Image):
        image_array = np.array(image)
    else:
        image_array = image.copy()
    
    # Make sure image is in RGB format (convert from grayscale if needed)
    if len(image_array.shape) == 2:
        # Convert grayscale to RGB
        image_array = np.stack([image_array] * 3, axis=2)
    elif len(image_array.shape) == 3 and image_array.shape[2] == 4:
        # If image has alpha channel, keep only RGB
        image_array = image_array[:, :, :3]
    
    # Create a blank RGBA array for the mask overlay
    # (RGB for color + Alpha for transparency)
    mask_overlay = np.zeros((*image_array.shape[:2], 4), dtype=np.uint8)
    
    # Set the RGB values to the specified color
    mask_overlay[:, :, 0] = color[0]  # R
    mask_overlay[:, :, 1] = color[1]  # G
    mask_overlay[:, :, 2] = color[2]  # B
    
    # Start with fully transparent overlay
    mask_overlay[:, :, 3] = 0  # Alpha channel (0 = transparent)
    
    # Process each mask
    for mask in masks:
        # Convert mask to numpy array if it's a PIL Image
        if isinstance(mask, Image.Image):
            mask_array = np.array(mask)
        else:
            mask_array = mask.copy()
        
        # Ensure mask is boolean
        if mask_array.dtype != bool:
            mask_array = mask_array > 0
        
        # Make sure mask has the same shape as the image
        if mask_array.shape != image_array.shape[:2]:
            # Create a new mask of the correct size
            temp_mask = np.zeros(image_array.shape[:2], dtype=bool)
            
            # Handle size differences
            h = min(mask_array.shape[0], image_array.shape[0])
            w = min(mask_array.shape[1], image_array.shape[1])
            
            # Copy the correct portion of the mask
            temp_mask[:h, :w] = mask_array[:h, :w]
            mask_array = temp_mask
        
        # Set alpha channel to semi-transparent for masked regions
        mask_overlay[:, :, 3][mask_array] = int(alpha * 255)
    
    # Convert arrays to PIL Images
    original_image = Image.fromarray(image_array)
    overlay_image = Image.fromarray(mask_overlay)
    
    # Paste the overlay onto the original image using the alpha channel as mask
    result = original_image.copy()
    result.paste(overlay_image, (0, 0), overlay_image)
    
    return result

def visualize_masks(image, masks, figsize=(12, 8)):
    """
    Visualize original image, masks, and transparent overlay in one figure.
    
    Args:
        image: PIL Image or numpy array
        masks: List of binary masks
        figsize: Figure size for matplotlib
    """
    # Create the transparent overlay
    overlay_image = create_transparent_mask_overlay(image, masks)
    
    # Convert images to numpy arrays if they're PIL Images
    if isinstance(image, Image.Image):
        image_array = np.array(image)
    else:
        image_array = image.copy()
        
    if len(image_array.shape) == 2:
        # Convert grayscale to RGB
        image_array = np.stack([image_array] * 3, axis=2)
    
    # Create a combined mask for visualization
    if masks:
        combined_mask = np.zeros(image_array.shape[:2], dtype=bool)
        for mask in masks:
            mask_array = np.array(mask) if isinstance(mask, Image.Image) else mask
            
            # Handle size differences
            h = min(mask_array.shape[0], combined_mask.shape[0])
            w = min(mask_array.shape[1], combined_mask.shape[1])
            temp = np.zeros_like(combined_mask)
            temp[:h, :w] = mask_array[:h, :w] > 0
            
            combined_mask = combined_mask | temp
    else:
        combined_mask = np.zeros(image_array.shape[:2], dtype=bool)
    
    # Create the figure
    fig, axes = plt.subplots(1, 3, figsize=figsize)
    
    # Display original image
    axes[0].imshow(image_array)
    axes[0].set_title('Original Image')
    axes[0].axis('off')
    
    # Display combined mask
    axes[1].imshow(combined_mask, cmap='Reds')
    axes[1].set_title('Masks')
    axes[1].axis('off')
    
    # Display overlay image
    axes[2].imshow(np.array(overlay_image))
    axes[2].set_title('Transparent Overlay')
    axes[2].axis('off')
    
    plt.tight_layout()
    plt.show()